---
layout: page
title: Dictionaries, tuples, functions, files
---

This modue includes:
1. **Dictionaries** – key/value mappings for fast lookup  
2. **Tuples** – immutable sequences for fixed collections  
3. **Functions** – reusable blocks of code with parameters and return values  
4. **File I/O** – reading from and writing to disk  

---

### 1. Dictionaries

A **dictionary** stores values indexed by unique keys (instead of by position):

```python
# Create a dictionary of word frequencies
freq = {
    "the": 69033,
    "of":  36998,
    "and": 30157
}

# Lookup by key
print(freq["the"])        # → 69033

# Add or update entries
freq["to"] = 21892
freq["and"] = 30500       # overwrite old value

# Remove an entry
del freq["of"]
````

### Iteration

Looping over a dictionary yields its keys; use `.values()` and `.items()` for values and (key, value) pairs:

```python
for word in freq:
    print(word)

for count in freq.values():
    print(count)

for word, count in freq.items():
    print(f"{word}: {count}")
```

### Common Methods

* `dict.keys()` → iterable of keys
* `dict.values()` → iterable of values
* `dict.items()` → iterable of `(key, value)` tuples
* `dict.get(key, default)` → safe lookup

```python
print(freq.get("of", 0))  # → 0  (instead of KeyError)
```

---

### 2. Tuples

A **tuple** is like a list but **immutable**—once created, you cannot change its elements:

```python
# Create and concatenate
t = (1, 2)
t = t + (3, 4)
print(t)                 # → (1, 2, 3, 4)

# Indexing and slicing
print(t[0])              # → 1
print(t[-1])             # → 4
print(t[1:3])            # → (2, 3)

# Unpacking
x, y, *rest = t
print(x, y, rest)        # → 1 2 [3, 4]
```

> **Use cases:** fixed configuration values, returning multiple values from functions, unpacking.

---

## Part III: Functions

Functions help you **DRY** (“Don’t Repeat Yourself”) your code. They take arguments and may return values.

### Defining a Function

```python
def greet(name):
    """Return a greeting for the given name."""
    return f"Hello, {name}!"

print(greet("Alice"))     # → "Hello, Alice!"
```

### Example 1: Safe Division

Avoid `ZeroDivisionError` by checking the denominator:

```python
def safe_divide(a, b):
    """Divide a by b; return None if b is zero."""
    if b == 0:
        return None
    return a / b

print(safe_divide(10, 2))  # → 5.0
print(safe_divide(10, 0))  # → None
```

### Example 2: Palindrome Checker

```python
def is_palindrome(s):
    """Return True if s reads the same forwards and backwards."""
    s = s.lower().replace(" ", "")
    return s == s[::-1]

print(is_palindrome("Race car"))  # → True
print(is_palindrome("Python"))    # → False
```

### Higher-Order Functions & Lambdas

```python
# Apply a function to all items in a list
nums = [1, 2, 3, 4]
squares = list(map(lambda x: x**2, nums))
print(squares)                  # → [1, 4, 9, 16]
```

---

### 4. File I/O

### Writing to a File

```python
data = ["apple", "banana", "cherry"]

with open("fruits.txt", "w", encoding="utf-8") as f:
    for fruit in data:
        f.write(fruit + "\n")
```

### Reading from a File

```python
with open("fruits.txt", "r", encoding="utf-8") as f:
    lines = f.readlines()
print(lines)                    
# → ['apple\n', 'banana\n', 'cherry\n']
```

### CSV Handling

```python
import csv

# Write CSV
with open("counts.csv", "w", newline="") as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(["word","count"])
    for w, c in freq.items():
        writer.writerow([w, c])

# Read CSV into a dictionary
counts = {}
with open("counts.csv", "r") as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        counts[row["word"]] = int(row["count"])
print(counts)
```

### JSON Handling

```python
import json

# Dump to JSON
with open("data.json", "w") as f:
    json.dump(freq, f, indent=2)

# Load from JSON
with open("data.json") as f:
    loaded = json.load(f)
print(loaded)
```

---

## Exercises

1. **Phonebook Dictionary**

   * Create a dict `phonebook` mapping names to phone numbers.
   * Add, update, delete entries.
   * Print all entries in the format `"Name: Number"`.

2. **Tuple Swapping**

   * Given `a, b = 5, 10`, swap their values in one line using tuple unpacking.
   * Print `a` and `b` after swapping.

3. **Function Composition**

   * Write a function `apply_and_sum(func, lst)` that applies `func` to each element of `lst` and returns the sum of results.
   * Test with `func=lambda x: x*2` and `lst=[1,2,3]`.

4. **Line Counter**

   * Write `count_lines(filename)` that returns the number of non-blank lines in a text file.
   * Use it on a sample `.txt` you create.

5. **CSV to JSON Converter**

   * Write `csv_to_json(csv_file, json_file)` that reads `csv_file` (with headers) into a list of dicts and writes it as JSON to `json_file`.
   * Verify by loading the JSON and printing the first record.

---